# QuickSort project
This repository contains my implementation of QuickSort based on the Hoare's algorithm. This is my way of splitting the array into three parts: values that less than pivot, values that equal to pivot, values that greater than pivot. During splitting, unnecessary swaps are avoided, which makes my algorithm adaptive. It does not require to copy the pivot (unless the data type is scalar).

## Details
At short, the sorting algorithm developed by _Charles_ _Hoare_ in 1960 contains several simple actions: _select_ a 'pivot' item from the array; _split_ the array to items that _less_ than the pivot and items that _greater_ than the pivot; _sort_ both parts recursively. The spliting is done using two pointers going toward each other.

Sorting is really fast. However, with all pluses of algorithm, there are minuses. In particular, extra swaps when both pointers stop on items that equal to pivot. If the array contains entirely or mostly of the same items, then there will be a lot of unnecessary work.

In this project, I developed a algorithm that avoids this problem. The splitting process consists of two stages. The _first_ _stage_ is like the Hoare's algorithm, two pointers are going toward each other. Items that greater than the pivot are moving to the end of array, lesser items are moving to the beginnig. If a item that equal to the pivot is found, then _second_ _stage_ is starting. While the splitting, all found items equal to the pivot are collecting and hold together each iteration. After this splitting into 3 parts, the lesser and greater items are sorting by recursive calls (like Bentley and McIlroy's algorithm).

The test results of (my and Hoare's) algorithms first versions were unsatisfactory. Even Hoare's algorithm produced huge results in some cases, so I optimized it: replace one recursive call with sorting in-place; select the pivot by median of three and put it into the array's center. As for my algorithm, this optimization became the foundation for the new version.

The test results of the latest versions have been impressive. My algorithm is not so slower than Hoare's algorithm but it is faster than std::sort. MergeSort is faster than the others thanks to the additional memory. My algorithm does not require the additional memory like all implementations of QuickSort.

But that is not all. I optimized my algorithm's final version for working with _scalar_ types (integer, floating). By storing the pivot value into a local variable, my algorithm's duration had approached to Hoare's. So I had divided my algorithm's behavior into work with scalar and non-scalar data.

## Testing
The testing were run on a virtual machine `MCBC` i586, 2 GB RAM. Used `gcc-4.1.3` without optimization options.

In addition to my algorithm and Hoare's algorithm, I took some algorithms from STL: HeapSort (std::make_heap, std::sort_heap), std::sort (made from QuickSort, HeapSort and InsertionSort) and std::stable_sort (aka MergeSort). The tests were run on arrays generated by following rules.

N   | Rule                       | Unique
----|----------------------------|-------
A1  | Already sorted (ascending) | Yes
A2  | All values are the same    | No
A3  | Only 0 & 1                 | No
A4  | Reversed (descending)      | Yes
A5  | All values are sorted except for the last item, the minimum | Yes
A6  | R-Bitonic (descending-mirrored)  | No
A7  | Bitonic (ascending-mirrored)     | No
A8  | R-Bitonic (descending-ascending) | Yes
A9  | Bitonic (ascending-descending)   | Yes

**Used abbreviations:**
* QS - QuickSort
* IS - InsertionSort
* HS - HeapSort
* SS - std::sort
* MS - MergeSort

The first test results in seconds (100000 integer values):

| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
|A1  |  0.01 |    0.02  |   0.02  | 0.08 | 0.01 | 0.02 |
|A2  |  0.01 |    0.03  |   0.03  | 0.08 | 0.02 | 0.02 |
|A3  |  0.01 |    0.03  |   0.03  | 0.09 | 0.03 | 0.02 |
|A4  |  0.02 |    0.02  |   0.02  | 0.10 | 0.01 | 0.03 |
|A5  |  0.03 |    0.02  |   0.02  | 0.10 | 0.11 | 0.02 |
|A6  | 56.40 |   16.20  |  16.22  | 0.10 | 0.09 | 0.02 |
|A7  | 44.62 |    0.79  |   0.79  | 0.10 | 0.09 | 0.02 |
|A8  | 56.45 |    0.35  |   0.35  | 0.10 | 0.09 | 0.02 |
|A9  | 89.27 |    0.13  |   0.13  | 0.10 | 0.09 | 0.02 |

After correction and optimization (100000 integer values):

| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
|A1  |  0.01 |   0.02   |   0.02  | 0.08 | 0.01 | 0.02 |
|A2  |  0.01 |   0.03   |   0.03  | 0.08 | 0.02 | 0.02 |
|A3  |  0.01 |   0.03   |   0.03  | 0.09 | 0.03 | 0.02 |
|A4  |  0.01 |   0.02   |   0.01  | 0.10 | 0.01 | 0.03 |
|A5  |  0.03 |   0.02   |   0.02  | 0.10 | 0.11 | 0.02 |
|A6  |  0.06 |   0.05   |   0.05  | 0.10 | 0.09 | 0.02 |
|A7  |  0.06 |   0.05   |   0.05  | 0.10 | 0.09 | 0.02 |
|A8  |  0.06 |   0.05   |   0.06  | 0.10 | 0.09 | 0.02 |
|A9  |  0.06 |   0.05   |   0.06  | 0.10 | 0.09 | 0.02 |

1000000 integer values:

| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
|A1  |  0.19 |   0.16   |   0.14  | 1.16 | 0.10 | 0.21 |
|A2  |  0.03 |   0.37   |   0.31  | 1.02 | 0.30 | 0.21 |
|A3  |  0.05 |   0.39   |   0.32  | 1.06 | 0.30 | 0.29 |
|A4  |  0.20 |   0.17   |   0.14  | 1.17 | 0.11 | 0.31 |
|A5  |  0.33 |   0.28   |   0.25  | 1.14 | 1.32 | 0.22 |
|A6  |  0.82 |   0.70   |   0.69  | 1.19 | 1.10 | 0.27 |
|A7  |  0.82 |   0.69   |   0.69  | 1.17 | 1.09 | 0.27 |
|A8  |  0.83 |   0.71   |   0.72  | 1.18 | 1.10 | 0.27 |
|A9  |  0.84 |   0.71   |   0.72  | 1.17 | 1.11 | 0.27 |

The same input data after the "scalar" optimization:

| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
|A1  |  0.17 |   0.16   |   0.14  | 1.16 | 0.10 | 0.21 |
|A2  |  0.03 |   0.37   |   0.31  | 1.02 | 0.30 | 0.21 |
|A3  |  0.04 |   0.39   |   0.32  | 1.06 | 0.30 | 0.29 |
|A4  |  0.17 |   0.17   |   0.14  | 1.17 | 0.11 | 0.31 |
|A5  |  0.28 |   0.28   |   0.25  | 1.14 | 1.32 | 0.22 |
|A6  |  0.70 |   0.69   |   0.69  | 1.19 | 1.10 | 0.27 |
|A7  |  0.69 |   0.69   |   0.68  | 1.17 | 1.09 | 0.27 |
|A8  |  0.71 |   0.71   |   0.72  | 1.18 | 1.10 | 0.27 |
|A9  |  0.71 |   0.71   |   0.72  | 1.17 | 1.11 | 0.27 |

The testing were run on a virtual machine `MCBC` i586, 2 GB RAM.  
Used `gcc-4.1.3`. Standard `C++03`. The test was compiled without optimization options.

Used abbreviations:
+ QS - QuickSort
+ IS - InsertionSort
+ HS - HeapSort
+ SS - std::sort
+ MS - MergeSort

I tested my algorithm and two variations of Hoare's: the pure version and the one with transferring to InsertionSort for ranges less than 32 items.
In addition to them, I took some algorithms from STL:
+ HeapSort (`std::make_heap, std::sort_heap`)
+ `std::sort` (made from QuickSort, HeapSort and InsertionSort)
+ `std::stable_sort` (aka MergeSort).

The tests were run on arrays generated by following rules.
N   | Rule | Unique
----|------|-------
A1  | Already sorted (ascending) | Yes
A2  | All values are the same    | No
A3  | Only 0 & 1                 | No
A4  | Reversed (descending)      | Yes
A5  | All values are sorted except for the last item, the minimum | Yes
A6  | R-Bitonic (descending-mirrored)  | No
A7  | Bitonic (ascending-mirrored)     | No
A8  | R-Bitonic (descending-ascending) | Yes
A9  | Bitonic (ascending-descending)   | Yes

**100000 integer values**

The first test results in seconds:
| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
| A1 |  0.01 |    0.02  |   0.02  | 0.08 | 0.01 | 0.02 |
| A2 |  0.01 |    0.03  |   0.03  | 0.08 | 0.02 | 0.02 |
| A3 |  0.01 |    0.03  |   0.03  | 0.09 | 0.03 | 0.02 |
| A4 |  0.02 |    0.02  |   0.02  | 0.10 | 0.01 | 0.03 |
| A5 |  0.03 |    0.02  |   0.02  | 0.10 | 0.11 | 0.02 |
| A6 | 56.40 |   16.20  |  16.22  | 0.10 | 0.09 | 0.02 |
| A7 | 44.62 |    0.79  |   0.79  | 0.10 | 0.09 | 0.02 |
| A8 | 56.45 |    0.35  |   0.35  | 0.10 | 0.09 | 0.02 |
| A9 | 89.27 |    0.13  |   0.13  | 0.10 | 0.09 | 0.02 |

After correction and optimization, *version 2*:
| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
| A1 |  0.01 |   0.02   |   0.02  | 0.08 | 0.01 | 0.02 |
| A2 |  0.01 |   0.03   |   0.03  | 0.08 | 0.02 | 0.02 |
| A3 |  0.01 |   0.03   |   0.03  | 0.09 | 0.03 | 0.02 |
| A4 |  0.01 |   0.02   |   0.01  | 0.10 | 0.01 | 0.03 |
| A5 |  0.03 |   0.02   |   0.02  | 0.10 | 0.11 | 0.02 |
| A6 |  0.06 |   0.05   |   0.05  | 0.10 | 0.09 | 0.02 |
| A7 |  0.06 |   0.05   |   0.05  | 0.10 | 0.09 | 0.02 |
| A8 |  0.06 |   0.05   |   0.06  | 0.10 | 0.09 | 0.02 |
| A9 |  0.06 |   0.05   |   0.06  | 0.10 | 0.09 | 0.02 |

After that, I had increased the load... **1000000 integer values**:
| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
| A1 |  0.19 |   0.16   |   0.14  | 1.16 | 0.10 | 0.21 |
| A2 |  0.03 |   0.37   |   0.31  | 1.02 | 0.30 | 0.21 |
| A3 |  0.05 |   0.39   |   0.32  | 1.06 | 0.30 | 0.29 |
| A4 |  0.20 |   0.17   |   0.14  | 1.17 | 0.11 | 0.31 |
| A5 |  0.33 |   0.28   |   0.25  | 1.14 | 1.32 | 0.22 |
| A6 |  0.82 |   0.67   |   0.67  | 1.19 | 1.10 | 0.27 |
| A7 |  0.82 |   0.67   |   0.67  | 1.17 | 1.09 | 0.27 |
| A8 |  0.83 |   0.70   |   0.70  | 1.18 | 1.10 | 0.27 |
| A9 |  0.84 |   0.70   |   0.70  | 1.17 | 1.11 | 0.27 |

The same input data after the "scalar" optimization:
| N  | QS my | QS Hoare | QS + IS |  HS  |  SS  |  MS  |
|:---|:-----:|:--------:|:-------:|:----:|:----:|:----:|
| A1 |  0.17 |   0.16   |   0.14  | 1.16 | 0.10 | 0.21 |
| A2 |  0.03 |   0.37   |   0.31  | 1.02 | 0.30 | 0.21 |
| A3 |  0.04 |   0.39   |   0.32  | 1.06 | 0.30 | 0.29 |
| A4 |  0.17 |   0.17   |   0.14  | 1.17 | 0.11 | 0.31 |
| A5 |  0.28 |   0.28   |   0.25  | 1.14 | 1.32 | 0.22 |
| A6 |  0.70 |   0.67   |   0.67  | 1.19 | 1.10 | 0.27 |
| A7 |  0.69 |   0.67   |   0.67  | 1.17 | 1.09 | 0.27 |
| A8 |  0.71 |   0.70   |   0.70  | 1.18 | 1.10 | 0.27 |
| A9 |  0.71 |   0.70   |   0.70  | 1.17 | 1.11 | 0.27 |
